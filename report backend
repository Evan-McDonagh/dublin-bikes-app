
Front-end Login

Once the main functionality of the frontend had been implemented, we then added the login feature. When a user is logged in, they are a presented with a slightly different version of the web page, with a favourites menu appearing in the navigation bar and an additional 'Add to favourites/Remove from Favourites' button appearing in the information section. They also have the option to access a form to edit their account details. Apart from this, the main functionaliy remains the same. The logic to display these different web pages to the logged in user is contained mostly in the back-end and makes use of the Jinja templating engine.


The favourites menu is populated and behaves very similarly to the all stations menu, but is based on a list of station ids stored in the user's entry in the database, which are passed to the front end when the user logs in.

The 'Add to favourites/Remove from Favourites' button appears when a user chooses to view more information about a station. When clicked, a function in JavaScript checks whether the current station is already in the favourites list, and sends a HTTP request to the server with the station ID and an add or remove argument as appropriate.

A number of forms are also used. which are implemented using Flask WTF extension. This which allows for the simple creation of forms with validation in the back-end. All the forms were designed with ease of use in mind, in order to give the user a better experience.





Backend overview

The backend logic of this web app was implemented mainly using Python, making use of the Flask microframework and its extensions. One powerful feature offered by flask is its use of the Jinja template engine, which we used extensively to simplify the creation of the html templates, as well as to implement some of the login logic and the forms.


Datascraping

The first step we undertook in the setting up the backend of this project was the scraping of the data we would need. We wished to obtain as much data as possible in order to get the most out of our machine learning model.

Bike Data

There are two types of data available from the Dublin Bikes API !!![RE,F]!!! dynamic data and static data. The static data gives details of the station names and their coordinates. As implied by its name, this data does not change frequently, and does not need regular updating. The dynamic data provides the occupancy data for each station, including the number of bikes available and the status of the station (whether it is open or closed). This information is constantly changing, and as such needs constant updating. 

For both of these types of data, we created python scripts to add the information to our database. Once these scripts were working from our local machines, we researched ways in which they could be could be run repeatedly and freqeuntly, such that the data in our database would always be up-to-date and so that we could store as much of the dynamic data as possible. We determined that it made most sense to use a virtual machine on Amazon's EC2 service. This VM would be constanty running and allow us to run the scripts at intervals at all times. One way in which we could have run the scripts at intervals was to use Python's 'sleep' function, and have the the main code block in an infinite while loop. We decided however, that it would be more elegant to use Linux's 'cron' module?????? . Cron is a task scheduler which allows the running or some abitrary code or function at regular intervals. We determined that the optimal timing for  the obaining of the dynmaic data is around 5 minutes, and the static data is updated daily.  

Weather

????









Database

There was a wide range of option for which database software to use, but we opted for a MySQL database simply because this is what we had most experience with. Our database has !!!!!!! schema: 
	- dynamicdata
	- staticdata
	- weatherdata
	- userinfo
More deatails on these schema can be found in the appendix.
The scraped data discussed in the previous section is stored in its corresponding table. the userinfo table store the login details and the favourited stations of each user and !!!!!!!!!!!
In the case of the dynamic bike data and the weather data, every time the data is scraped, new rows are added to the tables This gives us a history of all bike movements and weather information from the time our scraping was set up unitl the present. When the staticinfo table is updated, the old data is not needed so it is overwritten. 

As there is a limited set of SQL queries that we make to the database, we decided to create a stored procedure for each one. These are advantageous as they allow our python code to be simpler, due to the use of 'callproc', they can be more efficient when run multiple time, and they also provide an additional layer of security against SQL injection attacks. A list of these procedures along with their code can be found in the appendix.



Backend/Frontend Communication

A general overview of the commuication between the frontend and backend is as follows:

	- The Flask server receives a HTTP request from the frontend code.
	- The arguments in the HTTP request are used by Python to route it to the appropriate code block.
	- Either a stored procedure is called in the database, or html template is rendred.
	- The data or html is sent back as a ressponse to the HTTP request.

Flask uses 'routes' to process the HTTP requests it receives, and provides the functionatily required to retrieve the arguments from it and send data back to it. We used quite a few routes, allowing us to easily separate the different backend functionalities in code. To begin with we follwed a tutorial be Corey Schaefer in order to learn how these routes worked, before then building on this and designing our own. !!![REF]!!! While building the site, and while testing our user stories, we noticed that one of the most frequenlty used routes is that named 'query'. !!!NEEDS NEW NAME!!! This route is used when a user requests current station information. Due to its frequent use, we wiched to ensuire that there was as little delay as possible in getting the information requested. For simplicity in coding we considered retrieving the current information at all stations when this route was requested, however we found that it was considerably quicker to get the minimum amount of data needed. Similar considerations were taken with all routes inorder to provide the user with the best experience. 





Login Feature

!!!!as discussed in front end!!! We decided that a good additional feature for this web app would be to allow the user have a list of favourited stations, allowing them to more easily access the information about them. We decided that the best way to implement this would be too allow the user to login using their email address. We could then store their favourited stations in the database along with their email address.



This login feature is implemented using the 'flask_login' package, which adds a lot of the required functionality to Flask. Flask_login requires that a 'User' class be made, and an instance of this class is created when a user logs in. This instance is called current_user and its instance variables and associated methods are easily accesible in the code. 
Our implementation of the User class takes an email address as an argument, retrieves all the information about that user from the database, and stores the data as instance variables. It also has methods which all for updating and deleting the user data stored in the database. The functionalities associated with the login feature are outline below.

Register: When a user registers on the site, first we check whether the email address is already in use, as an email address can only be registered once. If it is a new email address, a stored procedure is called from Python to add a new entry to the uiserinfo table. This contains the user's email and their encrypted password, with their favourited stations set to an empty array and their email verified status to false.

Login: Once registered, the user is able to login. The login route retrieves the user's entry in the database and checks whether the input password matches the stored encryption, before logging the user in and redirecting them to the home page.

Account changes: Once logged in, the user is able , add or remove favourites, to alter the details of their account, or delete the account. All of this functionality is achieved using stored procedures which are called by methods in the User class.

Confirmation email: When a user registers for the site or when they update their email address, a confirmation email is sent to the provided email address. This email contains a URL with a token that identifies the email address it was sent to. This token is valid for a fixed period of time, and when the user navigates to this URL within the time frame, the route checks the token against the email addresses in the database. If the email address is found, it confirms they have access to the email they provided. This allows us to set their emailvalidated staus to true.

Password reset: Should the user forget their password, they have the option to reset it. This option is only available to a user when they have confirmed their email. Similary to the confirmation email, when a user requests a password reset for a confirmed email, they receive an email with a URL containing a time sensiteive token. This URL access the 'reset' route within Flask, which redirects them to a page which allows them to enter a new password.


Security

There was a range of security concerns to consider during the creation of the web application. 


SQL Injection

SQL Injection can occur when a malicious user takes advantage of SQL statements being sent to a database, allowing them to gain access to sensitive information or
to otherwise vandalise the database. In general, the HTTP requests sent to the Flask server contain arguments which are then used to find the right information in the database. A malicious user might replace the arguments in a HTTP request with some MySQL code which would cause undesirable behaviour in the database. In order to protect against this, we have ensured that we only access the database using 'callproc'. This function calls a stored procedure in the database with some given arguments. These arguments are escaped, however, meaning any SQL code inserted will be treated as a string of characters and not as executable code.


CSRF

Cross-site request forgery (CSRF) attacks occur when an attacker causes a user logged in to a site (or otherwise trusted by the site) to submit a request they did not intend to. An example might be causing a user to change their password unknowingly to a password the attacker knows, allowing the attacker access to their details. All of the forms on our site are implemented using Flask WTF, which provides a very simple way in which to protect against these attack. A CSRF token is included with all the forms as they are submitted, and if a form is recieved by the server that does not contain this token, the request will not be processed.


GDPR

	law.stackexchange.com/questions/32152/gdpr-cookie-for-login-management
	!!!! ADD USES COOKIES TO REMEMBER ME !!!
Cookies
Under GDPR rules, a user must provide informed consent before a cookie can be placed on their computer. A common method of doing this is by displaying a banner over the web page when a user visits a site for the first time, prompting them to accept the use of cookies. As our site does not use any cookies unless the user is logged in, this was deemed unecessary. Instead, a message stating that by logging in, the user consents to the use of cookies is placed on the login page.

Privacy Policy
By law, any site with a login !!!CHECK!!! requires a privacy policy which details how a users data will be used. We created a privacy policy for our web app using a template obtained here !!! WHERE !!!. A link to the privacy policy is available on the registration page !!AND ACCOUNT PAGE!!! and we indicate to the user that by registering the agree to the term in the privacy policy.



Data Storage

The GPPR policy on data storage states that the level of security needed is dependant on the level of sensitivity of the data !!!LINK!!!. We only store the users email address, their encrypted password, and their favourite stations, and thus we deemed a secure database with restricted access sufficient to comply with GDPR.






























